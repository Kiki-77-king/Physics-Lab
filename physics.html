<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>物理教学：平抛运动虚拟实验室</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1e1e1e; font-family: 'Consolas', 'Segoe UI', sans-serif; }
        
        /* 数据面板 */
        #data-panel {
            position: absolute; top: 20px; left: 20px; 
            background: rgba(0, 0, 0, 0.8); color: #00ffcc; 
            padding: 20px; border-radius: 8px; border: 1px solid #00ffcc;
            font-size: 16px; line-height: 1.8; pointer-events: none;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
            min-width: 200px;
        }
        .label { color: #aaa; margin-right: 10px; }
        .value { font-weight: bold; float: right; }
        
        /* 标题 */
        #title {
            position: absolute; top: 20px; right: 20px; color: white;
            text-align: right; pointer-events: none;
        }
        h1 { margin: 0; font-size: 24px; letter-spacing: 2px; }
        p { margin: 5px 0 0 0; color: #888; font-size: 14px; }

        /* 教学提示 */
        #tips {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.5); font-size: 14px; text-align: center;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="data-panel">
        <div><span class="label">时间 (t):</span> <span id="val-t" class="value">0.00 s</span></div>
        <hr style="border-color: #333">
        <div><span class="label">位移 X:</span> <span id="val-x" class="value">0.00 m</span></div>
        <div><span class="label">位移 Y:</span> <span id="val-y" class="value">0.00 m</span></div>
        <hr style="border-color: #333">
        <div><span class="label">速度 Vx:</span> <span id="val-vx" class="value">0.00 m/s</span></div>
        <div><span class="label">速度 Vy:</span> <span id="val-vy" class="value">0.00 m/s</span></div>
    </div>

    <div id="title">
        <h1>平抛运动实验室</h1>
        <p>Projectile Motion Simulator</p>
    </div>

    <div id="tips">
        红色球: 自由落体分量 | 蓝色球: 匀速直线分量
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- 物理参数配置 ---
        const PHYSICS = {
            height: 20,       // 初始高度 (m)
            v0: 15,           // 初速度 (m/s)
            gravity: 9.8,     // 重力加速度 (m/s²)
            timeScale: 1.0,   // 时间流速 (用于慢动作教学)
            
            // 状态
            isPlaying: false,
            currentTime: 0,
            
            // 控制
            start: () => startSimulation(),
            reset: () => resetSimulation(),
            showComponents: true // 是否显示分量球
        };

        let scene, camera, renderer, controls;
        let ball, ballShadowX, ballShadowY; // 主球，水平分量球，竖直分量球
        let trajectoryLine; // 轨迹线
        let platform, ground;

        // 缓存 DOM 元素以提高性能
        const ui = {
            t: document.getElementById('val-t'),
            x: document.getElementById('val-x'),
            y: document.getElementById('val-y'),
            vx: document.getElementById('val-vx'),
            vy: document.getElementById('val-vy')
        };

        init();
        animate();

        function init() {
            // 1. 场景设置
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e);
            scene.fog = new THREE.Fog(0x1e1e1e, 50, 150);

            // 2. 相机 (正交视角更有利于观察物理对齐，但透视视角更真实，这里选透视)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 80); // 侧面观察视角

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 开启阴影
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. 灯光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. 环境物体
            createEnvironment();

            // 6. 物理物体 (球体)
            createObjects();

            // 7. 控制器
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(20, 10, 0); // 视点看向运动区域中心

            // 8. GUI 面板
            initGUI();

            // 9. 初始计算
            updateTrajectoryPreview();
            
            window.addEventListener('resize', onWindowResize);
        }

        function createEnvironment() {
            // 地面网格
            const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
            scene.add(gridHelper);

            // 地面平面 (用于接收阴影)
            const planeGeo = new THREE.PlaneGeometry(100, 100);
            const planeMat = new THREE.MeshLambertMaterial({ color: 0x1e1e1e });
            ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            scene.add(ground);

            // 坐标轴辅助
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // 发射台 (升降台)
            const platformGeo = new THREE.BoxGeometry(2, 40, 2); // 高度拉长，通过位置控制露出部分
            const platformMat = new THREE.MeshPhongMaterial({ color: 0x555555 });
            platform = new THREE.Mesh(platformGeo, platformMat);
            platform.position.set(0, 0, 0); // Y轴位置会在 reset 时更新
            platform.castShadow = true;
            scene.add(platform);
        }

        function createObjects() {
            const sphereGeo = new THREE.SphereGeometry(0.8, 32, 32);

            // 主球 (白色 - 实际平抛)
            const mainMat = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x222222 });
            ball = new THREE.Mesh(sphereGeo, mainMat);
            ball.castShadow = true;
            scene.add(ball);

            // 竖直分量球 (红色 - 自由落体)
            const subYMat = new THREE.MeshBasicMaterial({ color: 0xff3333, transparent: true, opacity: 0.6 });
            ballShadowY = new THREE.Mesh(sphereGeo, subYMat);
            scene.add(ballShadowY);

            // 水平分量球 (蓝色 - 匀速直线)
            const subXMat = new THREE.MeshBasicMaterial({ color: 0x3333ff, transparent: true, opacity: 0.6 });
            ballShadowX = new THREE.Mesh(sphereGeo, subXMat);
            scene.add(ballShadowX);

            // 轨迹线 (虚线)
            // Three.js Line Basic Material 不支持宽度，但在教学中足够了
            // 预先创建 Geometry，之后在 update 中修改顶点
            const lineGeo = new THREE.BufferGeometry();
            const lineMat = new THREE.LineDashedMaterial({ 
                color: 0x00ffcc, 
                dashSize: 1, 
                gapSize: 0.5,
                scale: 1 
            });
            trajectoryLine = new THREE.Line(lineGeo, lineMat);
            scene.add(trajectoryLine);
        }

        function initGUI() {
            const gui = new GUI({ title: '实验控制台' });
            
            const folderParams = gui.addFolder('初始参数');
            folderParams.add(PHYSICS, 'height', 1, 40, 0.1).name('高度 h (m)').onChange(resetSimulation);
            folderParams.add(PHYSICS, 'v0', 0, 30, 0.1).name('初速度 v0 (m/s)').onChange(resetSimulation);
            folderParams.add(PHYSICS, 'gravity', 1, 20, 0.1).name('重力 g (m/s²)').onChange(resetSimulation);

            const folderControl = gui.addFolder('运行控制');
            folderControl.add(PHYSICS, 'timeScale', 0.1, 2.0).name('播放速度');
            folderControl.add(PHYSICS, 'showComponents').name('显示分量演示').onChange(updateVisibility);
            
            gui.add(PHYSICS, 'start').name('▶ 开始 / 继续');
            gui.add(PHYSICS, 'reset').name('↺ 重置');

            resetSimulation(); // 初始化位置
        }

        // 计算并在场景中画出预计轨迹 (核心物理逻辑)
        function updateTrajectoryPreview() {
            const points = [];
            const segments = 50; // 轨迹采样点数
            
            // 计算落地时间 t_end = sqrt(2h/g)
            const tTotal = Math.sqrt((2 * PHYSICS.height) / PHYSICS.gravity);
            
            for (let i = 0; i <= segments; i++) {
                const t = (i / segments) * tTotal;
                const x = PHYSICS.v0 * t;
                const y = PHYSICS.height - 0.5 * PHYSICS.gravity * t * t;
                points.push(new THREE.Vector3(x, y, 0));
            }
            
            trajectoryLine.geometry.setFromPoints(points);
            trajectoryLine.computeLineDistances(); // 必须调用，否则虚线不显示
        }

        function resetSimulation() {
            PHYSICS.isPlaying = false;
            PHYSICS.currentTime = 0;

            // 重置物体位置
            // 主球
            ball.position.set(0, PHYSICS.height, 0);
            
            // 分量球
            ballShadowY.position.set(0, PHYSICS.height, 0); // 红色球只在Y轴动，X=0
            ballShadowX.position.set(0, PHYSICS.height, 0); // 蓝色球只在X轴动，Y保持高度(或者Y=0看需求，通常演示为同一高度的匀速运动)
            // 教学修正：为了演示分解，蓝色球通常演示“如果在无重力下会去哪”或者“水平投影”。
            // 这里我们让蓝色球在空中水平飞，演示水平方向的匀速性。
            
            // 调整发射台高度视觉
            platform.position.y = PHYSICS.height / 2;
            platform.scale.y = PHYSICS.height / 20; // 基础高度20

            updateTrajectoryPreview();
            updateUI();
            updateVisibility();
        }

        function startSimulation() {
            if (ball.position.y <= 0 && PHYSICS.currentTime > 0) {
                // 如果已经落地，先重置再开始
                resetSimulation();
            }
            PHYSICS.isPlaying = true;
        }

        function updateVisibility() {
            ballShadowX.visible = PHYSICS.showComponents;
            ballShadowY.visible = PHYSICS.showComponents;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (PHYSICS.isPlaying) {
                // 1. 时间步进 (dt)
                // clock.getDelta() 不稳定，我们假设固定帧率或使用小步长，这里简化处理
                const dt = 0.016 * PHYSICS.timeScale; 
                PHYSICS.currentTime += dt;

                const t = PHYSICS.currentTime;
                const h = PHYSICS.height;
                const v0 = PHYSICS.v0;
                const g = PHYSICS.gravity;

                // 2. 物理方程 (核心)
                // x = v0 * t
                const x = v0 * t;
                // y = h - 1/2 * g * t^2
                const y = h - 0.5 * g * t * t;

                // 速度计算
                const vx = v0;
                const vy = -g * t; // 向下为负

                // 3. 落地检测
                if (y <= 0) {
                    PHYSICS.isPlaying = false;
                    // 强制修正到地面
                    updateBallPositions(x, 0, vx, vy, t); 
                } else {
                    updateBallPositions(x, y, vx, vy, t);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function updateBallPositions(x, y, vx, vy, t) {
            // 主球：合成运动
            ball.position.set(x, y, 0);

            // 红色球：只做自由落体 (x=0, y变化)
            ballShadowY.position.set(0, y, 0);

            // 蓝色球：只做匀速直线 (x变化, y=h) -> 也就是无重力的情况
            // 或者演示地面投影 (x变化, y=0.8)
            // 这里为了对比，让它保持在初始高度飞行，演示水平分量
            ballShadowX.position.set(x, PHYSICS.height, 0);

            updateUI(t, x, y, vx, vy);
        }

        function updateUI(t=0, x=0, y=PHYSICS.height, vx=PHYSICS.v0, vy=0) {
            ui.t.innerText = t.toFixed(2) + ' s';
            ui.x.innerText = x.toFixed(2) + ' m';
            ui.y.innerText = Math.max(0, y).toFixed(2) + ' m';
            ui.vx.innerText = vx.toFixed(2) + ' m/s';
            ui.vy.innerText = Math.abs(vy).toFixed(2) + ' m/s'; // 显示绝对值或者负值皆可
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>