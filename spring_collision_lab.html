<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ç‰©ç†æ¨¡æ‹Ÿï¼šå¼¹ç°§æŒ¯å­ä¸V-Tå›¾åƒ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1e1e1e; font-family: 'Consolas', 'Segoe UI', sans-serif; }
        
        /* æ•°æ®é¢æ¿ - æ‰©å¤§å®½åº¦ä»¥å®¹çº³å›¾è¡¨ */
        #data-panel {
            position: absolute; top: 20px; left: 20px; 
            background: rgba(0, 0, 0, 0.85); color: #00ffcc; 
            padding: 15px; border-radius: 8px; border-left: 3px solid #00ffcc;
            font-size: 13px; line-height: 1.5; pointer-events: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            width: 380px; /* åŠ å®½ */
            max-height: 90vh;
            overflow-y: auto;
        }
        /* æ¢å¤å›¾è¡¨çš„é¼ æ ‡äº‹ä»¶äº¤äº’ */
        #chart-container { pointer-events: auto; background: rgba(255,255,255,0.05); padding: 5px; border-radius: 4px; margin-top: 10px;}

        .section-title { color: #fff; border-bottom: 1px solid #555; margin-bottom: 5px; padding-bottom: 2px; margin-top: 10px; font-weight: bold; font-size: 14px;}
        .label { color: #aaa; margin-right: 10px; }
        .value { font-weight: bold; float: right; color: #fff;}
        .highlight { color: #ff3333; }

        /* æ ‡é¢˜ */
        #title {
            position: absolute; top: 20px; right: 20px; color: white;
            text-align: right; pointer-events: none;
        }
        h1 { margin: 0; font-size: 24px; letter-spacing: 1px; font-weight: normal;}
        p { margin: 5px 0 0 0; color: #666; font-size: 12px; text-transform: uppercase;}

        /* æ•™å­¦æç¤º */
        #tips {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; color: #888; font-size: 12px;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="data-panel">
        <div style="color: #fff; font-size: 16px; margin-bottom: 5px;">ğŸ“Š å®éªŒæ•°æ®ç›‘æµ‹</div>
        
        <div><span class="label">æ—¶é—´ (t):</span> <span id="val-t" class="value">0.00 s</span></div>
        
        <div class="section-title">é€Ÿåº¦-æ—¶é—´å›¾åƒ (V-T Graph)</div>
        <div id="chart-container" style="height: 200px;">
            <canvas id="vtChart"></canvas>
        </div>

        <div style="display: flex; justify-content: space-between; margin-top: 10px;">
            <div style="flex:1; margin-right:5px;">
                <div class="section-title" style="color:#3399ff">A (å·¦)</div>
                <div><span class="label">vA:</span> <span id="val-va" class="value">0.00</span></div>
                <div><span class="label">xA:</span> <span id="val-xa" class="value">0.00</span></div>
            </div>
            <div style="flex:1; margin-right:5px;">
                <div class="section-title" style="color:#33ff99">B (ä¸­)</div>
                <div><span class="label">vB:</span> <span id="val-vb" class="value">0.00</span></div>
                <div><span class="label">xB:</span> <span id="val-xb" class="value">0.00</span></div>
            </div>
            <div style="flex:1;">
                <div class="section-title" style="color:#ff3333">C (å³)</div>
                <div><span class="label">vC:</span> <span id="val-vc" class="value">0.00</span></div>
                <div><span class="label">xC:</span> <span id="val-xc" class="value">0.00</span></div>
            </div>
        </div>

        <div class="section-title">ç³»ç»Ÿèƒ½é‡</div>
        <div><span class="label">æ€»æœºæ¢°èƒ½ E:</span> <span id="val-energy" class="value">0.00 J</span></div>
    </div>

    <div id="title">
        <h1>åŠ¨é‡å®ˆæ’ä¸è°æŒ¯å­ V-T å¯è§†åŒ–</h1>
        <p>Velocity-Time Visualization & Simulation</p>
    </div>

    <div id="tips">
        å›¾è¡¨é¢œè‰²å¯¹åº”ç‰©ä½“é¢œè‰² | A:è“è‰² | B:ç»¿è‰² | C:çº¢è‰² (ç¢°æ’åä¸Bé‡åˆ)
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- 1. ç‰©ç†å‚æ•°ä¸çŠ¶æ€ ---
        const PHYSICS = {
            mA: 2.0, mB: 2.0, mC: 1.0,
            v0: 8.0,       // C åˆé€Ÿåº¦
            k: 15.0, L0: 8.0,
            
            t: 0, isPlaying: false, hasCollided: false,
            xA: 0, vA: 0,
            xB: 0, vB: 0,
            xC: 0, vC: 0,

            start: () => startSim(),
            reset: () => resetSim(),
            timeScale: 1.0
        };

        let scene, camera, renderer, controls;
        let meshA, meshB, meshC, springLine;
        let vtChart; // å›¾è¡¨å¯¹è±¡å…¨å±€å˜é‡
        const SPRING_SEGMENTS = 100;
        let frameCounter = 0; // ç”¨äºé™åˆ¶å›¾è¡¨æ›´æ–°é¢‘ç‡

        // UI ç¼“å­˜
        const ui = {
            t: document.getElementById('val-t'),
            va: document.getElementById('val-va'), xa: document.getElementById('val-xa'),
            vb: document.getElementById('val-vb'), xb: document.getElementById('val-xb'),
            vc: document.getElementById('val-vc'), xc: document.getElementById('val-xc'),
            energy: document.getElementById('val-energy'),
            dx: document.getElementById('val-dx')
        };

        init();
        animate();

        function init() {
            // --- Three.js åœºæ™¯æ­å»º (çœç•¥è¯¦ç»†æ³¨é‡Šï¼Œä¸ä¹‹å‰ç›¸åŒ) ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 50);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            createEnvironment();
            createObjects();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(5, 2, 0);
            controls.enableDamping = true;

            // --- åˆå§‹åŒ– GUI å’Œ å›¾è¡¨ ---
            initGUI();
            initChart(); // æ–°å¢ï¼šåˆå§‹åŒ–å›¾è¡¨

            resetSim();
            window.addEventListener('resize', onWindowResize);
        }

        // --- æ–°å¢ï¼šåˆå§‹åŒ– Chart.js å›¾è¡¨ ---
        function initChart() {
            const ctx = document.getElementById('vtChart').getContext('2d');
            Chart.defaults.color = '#aaa';
            Chart.defaults.borderColor = '#333';
            
            vtChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [], // Xè½´æ—¶é—´æ•°æ®
                    datasets: [
                        {
                            label: 'vA',
                            borderColor: '#3399ff', // A è“è‰²
                            borderWidth: 2,
                            pointRadius: 0, // ä¸æ˜¾ç¤ºæ•°æ®ç‚¹åœ†åœˆï¼Œæé«˜æ€§èƒ½
                            data: [],
                            tension: 0.1 // ç¨å¾®å¹³æ»‘ä¸€ç‚¹
                        },
                        {
                            label: 'vB',
                            borderColor: '#33ff99', // B ç»¿è‰²
                            borderWidth: 2,
                            pointRadius: 0,
                            data: []
                        },
                        {
                            label: 'vC',
                            borderColor: '#ff3333', // C çº¢è‰²
                            borderWidth: 2,
                            pointRadius: 0,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false, // å…³é—­åŠ¨ç”»ä»¥å®ç°å®æ—¶æ›´æ–°
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: 'Time (s)' },
                            ticks: { maxRotation: 0, stepSize: 1 }
                        },
                        y: {
                            title: { display: true, text: 'Velocity (m/s)' },
                            grid: { color: '#444' }
                        }
                    },
                    plugins: {
                        legend: { display: true, labels: { boxWidth: 12 } },
                        tooltip: { enabled: true, mode: 'index', intersect: false }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        function createEnvironment() {
            const grid = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
            scene.add(grid);
            const planeGeo = new THREE.PlaneGeometry(100, 20);
            const planeMat = new THREE.MeshPhongMaterial({ color: 0x2a2a2a });
            let ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createObjects() {
            const boxGeo = new THREE.BoxGeometry(2, 2, 2);
            meshA = new THREE.Mesh(boxGeo, new THREE.MeshPhongMaterial({ color: 0x3399ff }));
            meshB = new THREE.Mesh(boxGeo, new THREE.MeshPhongMaterial({ color: 0x33ff99 }));
            meshC = new THREE.Mesh(boxGeo, new THREE.MeshPhongMaterial({ color: 0xff3333 }));
            [meshA, meshB, meshC].forEach(m => { m.castShadow = true; m.receiveShadow = true; scene.add(m); });

            const springGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(SPRING_SEGMENTS * 3);
            springGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            springLine = new THREE.Line(springGeo, new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 }));
            scene.add(springLine);
        }

        function initGUI() {
            const gui = new GUI({ title: 'æ§åˆ¶å°' });
            const f1 = gui.addFolder('å‚æ•°è®¾ç½®');
            f1.add(PHYSICS, 'mA', 0.5, 5, 0.1).name('è´¨é‡ A').onChange(resetSim);
            f1.add(PHYSICS, 'mB', 0.5, 5, 0.1).name('è´¨é‡ B').onChange(resetSim);
            f1.add(PHYSICS, 'mC', 0.5, 5, 0.1).name('è´¨é‡ C').onChange(resetSim);
            f1.add(PHYSICS, 'v0', 1, 20, 0.5).name('Cåˆé€Ÿåº¦').onChange(resetSim);
            f1.add(PHYSICS, 'k', 1, 50, 1).name('åŠ²åº¦ k').onChange(resetSim);
            f1.add(PHYSICS, 'timeScale', 0.1, 2.0).name('æ—¶é—´æµé€Ÿ');
            f1.open();
            gui.add(PHYSICS, 'start').name('â–¶ å¼€å§‹ / æš‚åœ');
            gui.add(PHYSICS, 'reset').name('â†º é‡ç½®');
        }

        // --- æ ¸å¿ƒç‰©ç†é€»è¾‘ (ä¿æŒä¸å˜) ---
        function resetSim() {
            PHYSICS.isPlaying = false;
            PHYSICS.t = 0;
            PHYSICS.hasCollided = false;
            PHYSICS.xA = 0; PHYSICS.xB = PHYSICS.L0; PHYSICS.xC = PHYSICS.xB + 8;
            PHYSICS.vA = 0; PHYSICS.vB = 0; PHYSICS.vC = -PHYSICS.v0;
            
            // é‡ç½®å›¾è¡¨æ•°æ®
            if (vtChart) {
                vtChart.data.labels = [];
                vtChart.data.datasets.forEach(dataset => dataset.data = []);
                vtChart.update();
            }
            frameCounter = 0;

            updateVisuals(); updateSpring(); updateUI();
        }

        function startSim() { PHYSICS.isPlaying = !PHYSICS.isPlaying; }

        function solvePhysics(dt) {
            if (!PHYSICS.hasCollided) {
                if (PHYSICS.xC - PHYSICS.xB <= 2.0) { 
                    PHYSICS.hasCollided = true;
                    PHYSICS.xC = PHYSICS.xB + 2.0;
                    const vCommon = (PHYSICS.mB * PHYSICS.vB + PHYSICS.mC * PHYSICS.vC) / (PHYSICS.mB + PHYSICS.mC);
                    PHYSICS.vB = vCommon; PHYSICS.vC = vCommon;
                }
            }

            const springForce = PHYSICS.k * ((PHYSICS.xB - PHYSICS.xA) - PHYSICS.L0);
            const aA = springForce / PHYSICS.mA;
            let aB = 0;
            if (PHYSICS.hasCollided) {
                aB = -springForce / (PHYSICS.mB + PHYSICS.mC);
            } else {
                aB = -springForce / PHYSICS.mB;
            }

            PHYSICS.vA += aA * dt; PHYSICS.xA += PHYSICS.vA * dt;
            PHYSICS.vB += aB * dt; PHYSICS.xB += PHYSICS.vB * dt;

            if (PHYSICS.hasCollided) {
                PHYSICS.vC = PHYSICS.vB; PHYSICS.xC = PHYSICS.xB + 2.0;
            } else {
                PHYSICS.vC += 0; PHYSICS.xC += PHYSICS.vC * dt;
            }
            PHYSICS.t += dt;
        }

        function updateVisuals() {
            meshA.position.set(PHYSICS.xA, 1, 0);
            meshB.position.set(PHYSICS.xB, 1, 0);
            meshC.position.set(PHYSICS.xC, 1, 0);
        }

        function updateSpring() {
            const visualLen = (PHYSICS.xB - PHYSICS.xA) - 2.0; 
            const startX = PHYSICS.xA + 1.0;
            const positions = springLine.geometry.attributes.position.array;
            const radius = 0.5; const coils = 10;
            for (let i = 0; i < SPRING_SEGMENTS; i++) {
                const t = i / (SPRING_SEGMENTS - 1);
                positions[i*3] = startX + t * visualLen;
                positions[i*3+1] = 1 + Math.sin(t * Math.PI * 2 * coils) * radius;
                positions[i*3+2] = Math.cos(t * Math.PI * 2 * coils) * radius;
            }
            springLine.geometry.attributes.position.needsUpdate = true;
        }

        function updateUI() {
            ui.t.innerText = PHYSICS.t.toFixed(2) + ' s';
            ui.va.innerText = PHYSICS.vA.toFixed(2); ui.xa.innerText = PHYSICS.xA.toFixed(2);
            ui.vb.innerText = PHYSICS.vB.toFixed(2); ui.xb.innerText = PHYSICS.xB.toFixed(2);
            ui.vc.innerText = PHYSICS.vC.toFixed(2); ui.xc.innerText = PHYSICS.xC.toFixed(2);
            
            const Ek = 0.5*PHYSICS.mA*PHYSICS.vA**2 + 0.5*PHYSICS.mB*PHYSICS.vB**2 + 0.5*PHYSICS.mC*PHYSICS.vC**2;
            const Ep = 0.5 * PHYSICS.k * ((PHYSICS.xB - PHYSICS.xA) - PHYSICS.L0)**2;
            ui.energy.innerText = (Ek + Ep).toFixed(2) + ' J';

            if (PHYSICS.hasCollided) {
                ui.vc.style.color = ui.vb.style.color = '#ff9933'; // ç¢°æ’åBCå˜è‰²æç¤º
            } else {
                ui.vc.style.color = '#fff'; ui.vb.style.color = '#fff';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (PHYSICS.isPlaying) {
                const dt = 0.016 * PHYSICS.timeScale;
                const steps = 4;
                for(let i=0; i<steps; i++) solvePhysics(dt / steps);
                
                updateVisuals();
                updateSpring();
                updateUI();

                // --- å®æ—¶æ›´æ–°å›¾è¡¨æ•°æ® ---
                // ä¸ºäº†æ€§èƒ½ï¼Œæ¯éš”å‡ å¸§æ›´æ–°ä¸€æ¬¡å›¾è¡¨æ•°æ®ï¼Œè€Œä¸æ˜¯æ¯ä¸€å¸§
                frameCounter++;
                if (frameCounter % 5 === 0 && vtChart) {
                    // æ¨é€æ—¶é—´æˆ³
                    vtChart.data.labels.push(PHYSICS.t);
                    // æ¨é€ä¸‰ä¸ªç‰©ä½“çš„é€Ÿåº¦
                    vtChart.data.datasets[0].data.push(PHYSICS.vA);
                    vtChart.data.datasets[1].data.push(PHYSICS.vB);
                    vtChart.data.datasets[2].data.push(PHYSICS.vC);
                    
                    // é™åˆ¶å›¾è¡¨æ˜¾ç¤ºçš„æ•°æ®ç‚¹æ•°é‡ï¼Œé˜²æ­¢é•¿æ—¶é—´è¿è¡Œå¡é¡¿ (å¯é€‰)
                    // if (vtChart.data.labels.length > 500) {
                    //      vtChart.data.labels.shift();
                    //      vtChart.data.datasets.forEach(ds => ds.data.shift());
                    // }

                    // é«˜æ•ˆæ›´æ–°å›¾è¡¨ï¼ˆä¸å¸¦åŠ¨ç”»ï¼‰
                    vtChart.update('none');
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>