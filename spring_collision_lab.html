<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>物理模拟：弹簧振子与完全非弹性碰撞</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1e1e1e; font-family: 'Consolas', 'Segoe UI', sans-serif; }
        
        /* 数据面板 */
        #data-panel {
            position: absolute; top: 20px; left: 20px; 
            background: rgba(0, 0, 0, 0.85); color: #00ffcc; 
            padding: 20px; border-radius: 4px; border-left: 3px solid #00ffcc;
            font-size: 14px; line-height: 1.6; pointer-events: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            min-width: 240px;
        }
        .section-title { color: #fff; border-bottom: 1px solid #555; margin-bottom: 5px; padding-bottom: 2px; margin-top: 10px; font-weight: bold;}
        .label { color: #aaa; margin-right: 10px; }
        .value { font-weight: bold; float: right; color: #fff;}
        .highlight { color: #ff3333; } /* 碰撞高亮 */

        /* 标题 */
        #title {
            position: absolute; top: 20px; right: 20px; color: white;
            text-align: right; pointer-events: none;
        }
        h1 { margin: 0; font-size: 24px; letter-spacing: 1px; font-weight: normal;}
        p { margin: 5px 0 0 0; color: #666; font-size: 12px; text-transform: uppercase;}

        /* 教学提示 */
        #tips {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; color: #666; font-size: 12px;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="data-panel">
        <div style="color: #fff; font-size: 16px; margin-bottom: 10px;">实验数据监测</div>
        
        <div><span class="label">时间 (t):</span> <span id="val-t" class="value">0.00 s</span></div>
        
        <div class="section-title">物体 A (左侧)</div>
        <div><span class="label">速度 vA:</span> <span id="val-va" class="value">0.00 m/s</span></div>
        <div><span class="label">位置 xA:</span> <span id="val-xa" class="value">0.00 m</span></div>
        
        <div class="section-title">物体 B (中间/合体)</div>
        <div><span class="label">速度 vB:</span> <span id="val-vb" class="value">0.00 m/s</span></div>
        <div><span class="label">位置 xB:</span> <span id="val-xb" class="value">0.00 m</span></div>

        <div class="section-title">物体 C (入射)</div>
        <div><span class="label">速度 vC:</span> <span id="val-vc" class="value">0.00 m/s</span></div>

        <div class="section-title">系统能量 (验证守恒)</div>
        <div><span class="label">总机械能 E:</span> <span id="val-energy" class="value">0.00 J</span></div>
        <div><span class="label">弹簧形变 Δx:</span> <span id="val-dx" class="value">0.00 m</span></div>
    </div>

    <div id="title">
        <h1>动量守恒与谐振子</h1>
        <p>Inelastic Collision & Coupled Harmonic Motion</p>
    </div>

    <div id="tips">
        蓝色: 物体A | 绿色: 物体B | 红色: 物体C | 碰撞后 B与C 粘连共速
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- 1. 物理参数与状态 ---
        const PHYSICS = {
            // 参数
            mA: 2.0,        // 物体A质量
            mB: 2.0,        // 物体B质量
            mC: 1.0,        // 物体C质量
            v0: 10.0,       // C的初速度大小 (向左撞击)
            k: 15.0,        // 弹簧劲度系数
            L0: 8.0,        // 弹簧原长
            friction: 0.0,  // 地面摩擦系数 (默认光滑)

            // 状态
            t: 0,
            isPlaying: false,
            hasCollided: false, // 是否已经发生碰撞
            
            // 实时变量
            xA: 0, vA: 0,
            xB: 0, vB: 0,
            xC: 0, vC: 0,

            // 控制
            start: () => startSim(),
            reset: () => resetSim(),
            timeScale: 1.0
        };

        // --- 2. Three.js 全局变量 ---
        let scene, camera, renderer, controls;
        let meshA, meshB, meshC, springLine;
        let ground, wall;
        let springPoints = []; // 用于弹簧几何体更新
        const SPRING_SEGMENTS = 100;

        // UI 缓存
        const ui = {
            t: document.getElementById('val-t'),
            va: document.getElementById('val-va'), xa: document.getElementById('val-xa'),
            vb: document.getElementById('val-vb'), xb: document.getElementById('val-xb'),
            vc: document.getElementById('val-vc'),
            energy: document.getElementById('val-energy'),
            dx: document.getElementById('val-dx')
        };

        init();
        animate();

        function init() {
            // --- 场景搭建 ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e);

            // --- 相机 ---
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 40); // 俯视侧面

            // --- 渲染器 ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // --- 灯光 ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048; 
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // --- 环境物体 ---
            createEnvironment();

            // --- 物理实体 ---
            createObjects();

            // --- 控制器 ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(5, 2, 0);
            controls.enableDamping = true;

            // --- GUI ---
            initGUI();

            // --- 初始化状态 ---
            resetSim();
            
            window.addEventListener('resize', onWindowResize);
        }

        function createEnvironment() {
            // 地面网格
            const grid = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
            scene.add(grid);
            
            // 物理平面
            const planeGeo = new THREE.PlaneGeometry(100, 20);
            const planeMat = new THREE.MeshPhongMaterial({ color: 0x2a2a2a });
            ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // 轨道装饰线 (表示无摩擦轨道)
            const trackGeo = new THREE.BoxGeometry(100, 0.1, 0.5);
            const trackMat = new THREE.MeshBasicMaterial({ color: 0x444444 });
            const track = new THREE.Mesh(trackGeo, trackMat);
            track.position.y = 0.05;
            scene.add(track);
        }

        function createObjects() {
            const boxGeo = new THREE.BoxGeometry(2, 2, 2);
            
            // 物体 A (左) - 蓝色
            meshA = new THREE.Mesh(boxGeo, new THREE.MeshPhongMaterial({ color: 0x3399ff }));
            meshA.castShadow = true;
            meshA.receiveShadow = true;
            scene.add(meshA);

            // 物体 B (中) - 绿色
            meshB = new THREE.Mesh(boxGeo, new THREE.MeshPhongMaterial({ color: 0x33ff99 }));
            meshB.castShadow = true;
            meshB.receiveShadow = true;
            scene.add(meshB);

            // 物体 C (右，入射) - 红色
            meshC = new THREE.Mesh(boxGeo, new THREE.MeshPhongMaterial({ color: 0xff3333 }));
            meshC.castShadow = true;
            meshC.receiveShadow = true;
            scene.add(meshC);

            // 弹簧 (自定义 LineGeometry)
            const springGeo = new THREE.BufferGeometry();
            // 预分配顶点位置
            const positions = new Float32Array(SPRING_SEGMENTS * 3);
            springGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const springMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            springLine = new THREE.Line(springGeo, springMat);
            scene.add(springLine);

            // 标签 (简单的文字精灵或者仅仅通过颜色区分，这里用颜色区分足够)
        }

        function initGUI() {
            const gui = new GUI({ title: '物理实验控制台' });
            
            const f1 = gui.addFolder('质量设置 (kg)');
            f1.add(PHYSICS, 'mA', 0.5, 10, 0.1).name('物体 A').onChange(resetSim);
            f1.add(PHYSICS, 'mB', 0.5, 10, 0.1).name('物体 B').onChange(resetSim);
            f1.add(PHYSICS, 'mC', 0.5, 10, 0.1).name('物体 C').onChange(resetSim);

            const f2 = gui.addFolder('初始条件');
            f2.add(PHYSICS, 'v0', 1, 30, 0.5).name('C 初速度 (m/s)').onChange(resetSim);
            f2.add(PHYSICS, 'k', 1, 50, 1).name('弹簧劲度 k (N/m)').onChange(resetSim);
            f2.add(PHYSICS, 'L0', 4, 15, 0.5).name('弹簧原长 L0 (m)').onChange(resetSim);

            const f3 = gui.addFolder('运行控制');
            f3.add(PHYSICS, 'timeScale', 0.1, 2.0).name('时间流速');
            f3.add(PHYSICS, 'start').name('▶ 开始 / 暂停');
            f3.add(PHYSICS, 'reset').name('↺ 重置实验');
        }

        // --- 核心物理逻辑 ---

        function resetSim() {
            PHYSICS.isPlaying = false;
            PHYSICS.t = 0;
            PHYSICS.hasCollided = false;

            // 初始位置
            // A 在原点左侧，为了让 B 在原点附近好看一点，我们设 A = -L0/2, B = L0/2
            // 或者简单点：A = 0, B = L0
            PHYSICS.xA = 0;
            PHYSICS.xB = PHYSICS.L0;
            
            // C 在 B 右侧一定距离，准备撞击
            const startDist = 10; 
            PHYSICS.xC = PHYSICS.xB + startDist;

            // 初始速度
            PHYSICS.vA = 0;
            PHYSICS.vB = 0;
            PHYSICS.vC = -PHYSICS.v0; // 向左运动

            // 同步视觉模型
            updateVisuals();
            updateSpring();
            updateUI();
        }

        function startSim() {
            PHYSICS.isPlaying = !PHYSICS.isPlaying;
        }

        function solvePhysics(dt) {
            // 1. 碰撞检测
            // 假设物体宽度为 2 (半径为1)，当中心距离 <= 2 时碰撞
            // 碰撞条件：C 在 B 右边，向左运动，且接触
            if (!PHYSICS.hasCollided) {
                const dist = PHYSICS.xC - PHYSICS.xB;
                if (dist <= 2.0) { // 发生完全非弹性碰撞
                    PHYSICS.hasCollided = true;
                    
                    // 修正位置防止穿模
                    PHYSICS.xC = PHYSICS.xB + 2.0;

                    // --- 动量守恒计算 ---
                    // mB*vB + mC*vC = (mB+mC)*vBC
                    const momentum = PHYSICS.mB * PHYSICS.vB + PHYSICS.mC * PHYSICS.vC;
                    const newMass = PHYSICS.mB + PHYSICS.mC;
                    const vCommon = momentum / newMass;

                    PHYSICS.vB = vCommon;
                    PHYSICS.vC = vCommon;

                    console.log(`碰撞发生! 共速 v = ${vCommon.toFixed(3)} m/s`);
                }
            }

            // 2. 力学计算
            // 弹簧力 F = k * (current_len - L0)
            const currentLen = PHYSICS.xB - PHYSICS.xA; // B在右，A在左
            const deltaX = currentLen - PHYSICS.L0;
            const springForce = PHYSICS.k * deltaX; // 如果伸长(>0)，力向左拉B，向右拉A

            // 3. 加速度计算
            // 物体 A 受力: +springForce (向右)
            const aA = springForce / PHYSICS.mA;
            
            // 物体 B 受力: -springForce (向左)
            // 如果碰撞了，B和C一起运动，视为一个整体
            let aB = 0;
            if (PHYSICS.hasCollided) {
                // 整体质量 mB + mC
                const mTotal = PHYSICS.mB + PHYSICS.mC;
                aB = -springForce / mTotal;
                // C 的加速度与 B 相同
                var aC = aB; 
            } else {
                // 碰撞前 B 只受弹簧力 (其实碰撞前弹簧是原长，力为0，除非有扰动)
                aB = -springForce / PHYSICS.mB;
                // C 碰撞前不受力 (忽略摩擦)
                var aC = 0;
            }

            // 4. 欧拉积分 (更新速度和位置)
            PHYSICS.vA += aA * dt;
            PHYSICS.xA += PHYSICS.vA * dt;

            PHYSICS.vB += aB * dt;
            PHYSICS.xB += PHYSICS.vB * dt;

            if (PHYSICS.hasCollided) {
                PHYSICS.vC = PHYSICS.vB; // 强制共速
                PHYSICS.xC = PHYSICS.xB + 2.0; // 强制紧贴
            } else {
                PHYSICS.vC += aC * dt;
                PHYSICS.xC += PHYSICS.vC * dt;
            }

            PHYSICS.t += dt;
        }

        // --- 渲染循环 ---

        function updateVisuals() {
            meshA.position.set(PHYSICS.xA, 1, 0); // y=1 因为盒子高度2
            meshB.position.set(PHYSICS.xB, 1, 0);
            meshC.position.set(PHYSICS.xC, 1, 0);
        }

        function updateSpring() {
            // 在 A 和 B 之间绘制螺旋线
            const start = new THREE.Vector3(PHYSICS.xA, 1, 0);
            const end = new THREE.Vector3(PHYSICS.xB, 1, 0);
            const direction = new THREE.Vector3().subVectors(end, start);
            const len = direction.length();
            
            // 修正：弹簧不应该连接中心，应该连接表面
            // A右表面: xA + 1, B左表面: xB - 1
            // 实际弹簧长度
            const visualLen = len - 2.0; 
            const startX = PHYSICS.xA + 1.0;
            
            const positions = springLine.geometry.attributes.position.array;
            
            const radius = 0.5; // 弹簧半径
            const coils = 10;   // 圈数

            for (let i = 0; i < SPRING_SEGMENTS; i++) {
                const t = i / (SPRING_SEGMENTS - 1); // 0 到 1
                
                // x 坐标线性插值
                const x = startX + t * visualLen;
                // y, z 坐标正弦震荡形成螺旋
                const angle = t * Math.PI * 2 * coils;
                const y = 1 + Math.sin(angle) * radius;
                const z = Math.cos(angle) * radius;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }
            springLine.geometry.attributes.position.needsUpdate = true;
        }

        function updateUI() {
            ui.t.innerText = PHYSICS.t.toFixed(2) + ' s';
            
            ui.va.innerText = PHYSICS.vA.toFixed(3) + ' m/s';
            ui.xa.innerText = PHYSICS.xA.toFixed(2) + ' m';
            
            ui.vb.innerText = PHYSICS.vB.toFixed(3) + ' m/s';
            ui.xb.innerText = PHYSICS.xB.toFixed(2) + ' m';

            ui.vc.innerText = PHYSICS.vC.toFixed(3) + ' m/s';

            // 能量计算
            const EkA = 0.5 * PHYSICS.mA * PHYSICS.vA * PHYSICS.vA;
            const EkB = 0.5 * PHYSICS.mB * PHYSICS.vB * PHYSICS.vB;
            const EkC = 0.5 * PHYSICS.mC * PHYSICS.vC * PHYSICS.vC;
            
            const currentSpringLen = PHYSICS.xB - PHYSICS.xA;
            const dx = currentSpringLen - PHYSICS.L0;
            const Ep = 0.5 * PHYSICS.k * dx * dx;

            const totalE = EkA + EkB + EkC + Ep;

            ui.energy.innerText = totalE.toFixed(3) + ' J';
            ui.dx.innerText = dx.toFixed(3) + ' m';

            // 碰撞状态视觉反馈 (C变色或UI变色)
            if (PHYSICS.hasCollided) {
                ui.vc.style.color = '#ff3333'; // 红色表示碰撞后
                meshC.material.color.setHex(0xaa0000); // 变深红
            } else {
                ui.vc.style.color = '#fff';
                meshC.material.color.setHex(0xff3333);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (PHYSICS.isPlaying) {
                // 使用较小的时间步长循环多次以保证物理稳定性
                const dt = 0.016 * PHYSICS.timeScale;
                const steps = 4; // 子步
                for(let i=0; i<steps; i++) {
                    solvePhysics(dt / steps);
                }
                updateVisuals();
                updateSpring();
                updateUI();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>